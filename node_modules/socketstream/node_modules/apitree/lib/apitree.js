(function() {
  var Path, createApiTree, fs;
  var __hasProp = Object.prototype.hasOwnProperty, __indexOf = Array.prototype.indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (__hasProp.call(this, i) && this[i] === item) return i; } return -1; };

  fs = require('fs');

  Path = require('path');

  exports.createApiTree = createApiTree = function(directory, options) {
    var child, item, k, key, name, names, node, tree, v, _i, _len;
    if (options == null) options = {};
    options.loadItem || (options.loadItem = require);
    options.nameToKey || (options.nameToKey = function(name) {
      return name.split('.')[0].replace(/_*\W+_*/g, '_');
    });
    options.readdirSync || (options.readdirSync = function(path) {
      return fs.readdirSync(path);
    });
    options.isDirectory || (options.isDirectory = function(path) {
      return fs.lstatSync(path).isDirectory();
    });
    options.filter || (options.filter = function(name, names) {
      var _ref;
      return name.match(/\.js$/) || (name.match(/\.coffee$/) && !(_ref = name.replace(/\.coffee$/, '.js'), __indexOf.call(names, _ref) >= 0));
    });
    tree = {};
    names = options.readdirSync(directory);
    for (_i = 0, _len = names.length; _i < _len; _i++) {
      name = names[_i];
      if (name.match(/^[._#]|[#~]$/)) continue;
      child = Path.join(directory, name);
      key = options.nameToKey(name);
      item = options.isDirectory(child) ? createApiTree(child, options) : options.filter(name, names) ? options.loadItem(child) : void 0;
      if (item && Object.keys(item).length) {
        node = (tree[key] || (tree[key] = {}));
        for (k in item) {
          if (!__hasProp.call(item, k)) continue;
          v = item[k];
          if (node[k] != null) {
            throw new Error("API tree name conflict for '" + k + "' in " + child);
          }
          node[k] = v;
        }
      }
    }
    return tree;
  };

}).call(this);
